Детайли по имплементацията, които да влезнат по-късно в теоретичното описание.

1. Мотивация за избор на схема - BFV предимства - точни операции, възможност за поддържане на двете хомоморфни операции
без да е необхдимо да се имплементира тежката bootstrapping процедура. Основно предимство в контекста на дипломнатат работа
е простотата на схемата, която я праи по-лесно разбираема.

2. Мотивация за избор на технологията JAVA - бързодействие в сравнение с Python

3. Библиотеки
    - Apache Commons Maths
    - Junit for testing purposes
    - !!!! за проблема с операция върху BigInteger числа удачен вариант за използване е библиотеката
https://guava.dev/releases/19.0/api/docs/com/google/common/math/BigIntegerMath.html - предоставя добри възможности за изпълнение
на математически операциия - логаритъм, корен и др. върху числа от типа BigInteger с подходяща прецизност - тези операции са от изключителна
важност при имплементацията на хомоморфна схема.
Тук https://stackoverflow.com/questions/6827516/logarithm-for-biginteger също има подходяща имплементация на метод за
взимане на логаритъм при всякаква база с възможности за различна точност.

---> https://stackoverflow.com/questions/739532/logarithm-of-a-bigdecimal


4. On the question of bootstrapping https://www.zama.ai/post/what-is-bootstrapping-homomorphic-encryption - should also include leveled explanation
could use the demo that is described in SEAL - levels
BGV/BFV
In these schemes, bootstrapping increases the level associated with a ciphertext, and also reduces the noise.
The input and output ciphertext from the bootstrap operation will encrypt the same underlying message (i.e. the clear message is not modified).
A BGV/BFV computation looks like a sequence of additions and multiplication operations, where one tries to minimize the depth of the multiplication operations.
The higher the depth, the more bootstrap operations are needed.
Bootstrapping in BGV/BFV takes a long time, i.e. it has high latency, however, due to ciphertext packing, one can obtain reasonable amortized times.
The table below provides further information.


from: https://eprint.iacr.org/2021/204.pdf
The first class primarily works with Boolean circuits and decision diagrams, similar to
the original Gentry scheme, and includes the FHEW and TFHE schemes [13, 17]. The second class
supports modular arithmetic over finite fields, which typically correspond to vectors of integers mod
t, where t is a prime power commonly called as the plaintext modulus. The second class is also
sometimes used for small-integer arithmetic. This class includes Brakerski-Gentry-Vaikuntantan
(BGV) and Brakerski/Fan-Vercauteren (BFV) schemes [9, 10, 18]. The third, and most recent, class
supports approximate computations over vectors of real and complex numbers, and is represented
by the Cheon-Kim-Kim-Song (CKKS) scheme [12]. All these schemes are based on the hardness
of the Ring Learning With Errors (RLWE) problem, where noise is added during encryption and
key generation to achieve the hardness properties. The noise grows as encrypted computations
are performed, and the main functional parameter in all these schemes, the ciphertext modulus Q,
needs to be large enough to accommodate the noise growth, or a special bootstrapping procedure
may be used to reset the noise and keep the value of Q relatively small.

Although the BGV and BFV schemes
work with the same plaintext algebra, they use different strategies for encoding the message composed of integers in Zt and controlling the noise. The BGV scheme encodes the message in the least
significant digit (LSD) of integers in ZQ and applies the modulus switching technique to keep the
noise magnitude constant, i.e., it scales down Q by a factor that corresponds to the noise added
after the previous modulus switching call. The BFV scheme encodes the message in the most significant digit (MSD) of integers in ZQ and uses a special form of homomorphic multiplication, where
ciphertext polynomials are multiplied without modular reduction and then scaled down by Q/t. In
BFV, the value of Q is typically constant and the noise magnitude increases at a rate similar to how
Q decreases in BGV. The difference in noise management strategies between BGV and BFV affects
the noise growth and efficiency of the schemes. Costache and Smart performed a noise growth
comparison, which suggested that BGV has better noise growth for larger t than BFV [15]. However,
the authors did not examine the computational complexity difference, and it has not been clear
up to this moment how the schemes compare in terms of practical performance, both from the
perspective of computational complexity and actual experimental measurements.



Plaintext space:
We are interested in the BGV and BFV homomorphic encryption schemes which both share the same
plaintext space Rt for some integer t > 1. Hence, the most natural way to represent plaintext
messages of these schemes is to think of them as vectors of size N with their coefficients taken
modulo t. However, Rt has many algebraic properties, in particular when t = p
r
is a prime power
with p coprime to 2N. In this case Rt
is actually a Zt-algebra, which means that it contains a
subring isomorphic to Zt
. In this paper we focus on the case r = 1, where t = p is a prime.
The interested reader can nonetheless refer to [25] for further details regarding the general case.
Zt-algebra supports efficent Single-Instruction Multiple-Data (SIMD) packing/batching. For more
details on the packing, the reader is referred to [32].

In [9], Brakerski proposed a scale-invariant construction that achieves asymptotically the same
noise growth as BGV, but does not explicitly call the modulus-switching procedure, embedding
it internally in the homomorphic multiplication.

Check out page 19 <= todo
the new multiplication algorithm -  could be another optimization



Допълни в глава 1 - BGV and BFV are often used for applications that work with large vectors of small integers.
Common examples include private information retrieval and private set intersection, which are often used in secure database query applications.
--> https://dualitytech.com/blog/bootstrapping-in-fully-homomorphic-encryption-fhe/



16.05 - рефакторинг:
1. За степен на полином е използван тип integer вместо BigInteger от съображения за евентуална загуба на точност
при взимане на цяла стойност от Biginteger
понеже тя се използва при обхождане на цикъл и индексиране на стойности.
Java Integer range - -2147483648 to 2147483647.
Друг вариант би бил long, но отново нуждата от експлицитно преобразуване в интиджър би довела до загуба на прецизност.

17.05 - рефакторинг:
методите за работа с полиноми  --> https://www.geeksforgeeks.org/comparing-streams-to-loops-in-java/
Advantages of Streams

Streams are a more declarative style. Or a more expressive style.
Streams have a strong affinity with functions. Java 8 introduces lambdas and functional interfaces, which opens a whole toolbox of powerful techniques. Streams provide the most convenient and natural way to apply functions to sequences of objects.
Streams encourage less mutability. This is sort of related to the functional programming aspect i.e., the kind of programs we write using streams tend to be the kind of programs where we don’t modify objects.
Streams encourage loose coupling. Our stream-handling code doesn’t need to know the source of the stream or its eventual terminating method.
Streams can succinctly express quite sophisticated behavior.


Advantages of Loops

Performance: A for loop through an array is extremely lightweight both in terms of heap and CPU usage. If raw speed and memory thriftiness is a priority, using a stream is worse.
Familiarity: The world is full of experienced procedural programmers, from many language backgrounds, for whom loops are familiar and streams are novel. In some environments, you want to write code that’s familiar to that kind of person.
Cognitive overhead: Because of its declarative nature, and increased abstraction from what’s happening underneath, you may need to build a new mental model of how code relates to execution. Actually, you only need to do this when things go wrong, or if you need to deeply analyze performance or subtle bugs. When it “just works”, it just works.
Debuggers are improving, but even now, when we are stepping through stream code in a debugger, it can be harder work than the equivalent loop, because a simple loop is very close to the variables and code locations that a traditional debugger works with.

We can use Java’s concurrency utilities, such as ExecutorService, to execute tasks concurrently.
We divide the list into chunks and process them concurrently using a thread pool.
When deciding between streams and for-loops for parallelism and concurrency, we should consider the complexity of our task.
Streams offer a more straightforward way to enable parallel processing for tasks that can be parallelized easily.
On the other hand, for-loops, with manual concurrency control, are suitable for more complex scenarios that require custom thread management and coordination.



todo - must check if this polynomial to string is a good variant
IntStream.range(0, this.polynomialDegree)
                .filter(i -> !coefficients[i].equals(BigInteger.ZERO))
                .mapToObj(i -> {
                    StringBuilder term = new StringBuilder();

                    if (i > 0) {
                        term.append("x");
                        if (i > 1) {
                            term.append("^").append(i);
                        }
                    } else {
                        term.append(coefficients[i]);
                    }

                    return term.toString();
                })
                .collect(Collectors.joining(" + "));

Also benchmark the efficiency of parallel stream - CRT is the mpst time consuming method - this is the motivation to search for alternatives


20.05:
Optimize functionality - if unable to perform batching at once, split the data into multiple small-length pieces